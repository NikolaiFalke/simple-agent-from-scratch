{
  "nodes": [
    {
      "parameters": {
        "description": "Intelligent pattern detection engine that finds similar service cases based on machine models, descriptions, severity, and technical patterns. Identifies recurring issues and solution patterns for proactive service optimization. Triggers detailed analysis when 3+ similar cases are detected.",
        "jsCode": "// Similar Cases Detection Engine\n// Finds patterns across service cases for intelligence and optimization\n\nconst targetCase = $input.first().json.targetCase;\nconst allCases = $input.first().json.allCases || [];\nconst similarityThreshold = $input.first().json.threshold || 0.6;\nconst maxResults = $input.first().json.maxResults || 10;\n\nif (!targetCase) {\n  return { error: 'Target case data is required for similarity analysis' };\n}\n\n// Similarity scoring functions\nfunction calculateMachineModelSimilarity(case1, case2) {\n  const machine1 = case1.serviceCaseMachineSnapshot;\n  const machine2 = case2.serviceCaseMachineSnapshot;\n  \n  if (!machine1 || !machine2) return 0;\n  \n  let score = 0;\n  \n  // Exact model match (highest weight)\n  if (machine1.modelName === machine2.modelName) score += 0.4;\n  \n  // Brand match\n  if (machine1.brand === machine2.brand) score += 0.2;\n  \n  // Technology match\n  if (machine1.technology === machine2.technology) score += 0.3;\n  \n  // Serial number pattern (for same model variants)\n  if (machine1.serialNumber && machine2.serialNumber) {\n    const serial1Prefix = machine1.serialNumber.substring(0, 6);\n    const serial2Prefix = machine2.serialNumber.substring(0, 6);\n    if (serial1Prefix === serial2Prefix) score += 0.1;\n  }\n  \n  return Math.min(score, 1.0);\n}\n\nfunction calculateDescriptionSimilarity(desc1, desc2) {\n  if (!desc1 || !desc2) return 0;\n  \n  const words1 = desc1.toLowerCase().split(/\\s+/).filter(w => w.length > 3);\n  const words2 = desc2.toLowerCase().split(/\\s+/).filter(w => w.length > 3);\n  \n  if (words1.length === 0 || words2.length === 0) return 0;\n  \n  const commonWords = words1.filter(word => words2.includes(word));\n  const similarity = commonWords.length / Math.max(words1.length, words2.length);\n  \n  return similarity;\n}\n\nfunction calculateTitleSimilarity(title1, title2) {\n  if (!title1 || !title2) return 0;\n  \n  const words1 = title1.toLowerCase().split(/\\s+/);\n  const words2 = title2.toLowerCase().split(/\\s+/);\n  \n  if (words1.length === 0 || words2.length === 0) return 0;\n  \n  const commonWords = words1.filter(word => words2.includes(word));\n  return commonWords.length / Math.max(words1.length, words2.length);\n}\n\nfunction calculateSeveritySimilarity(sev1, sev2) {\n  if (sev1 === sev2) return 1.0;\n  \n  // Severity similarity matrix\n  const severityMatrix = {\n    'MACHINE_BREAKDOWN': { 'PRODUCTION_IMPAIRED': 0.6, 'NO_IMPAIRMENT': 0.2 },\n    'PRODUCTION_IMPAIRED': { 'MACHINE_BREAKDOWN': 0.6, 'NO_IMPAIRMENT': 0.4 },\n    'NO_IMPAIRMENT': { 'MACHINE_BREAKDOWN': 0.2, 'PRODUCTION_IMPAIRED': 0.4 }\n  };\n  \n  return severityMatrix[sev1]?.[sev2] || 0;\n}\n\nfunction calculateCustomerSimilarity(case1, case2) {\n  const customer1 = case1.serviceCaseCustomerMachineSnapshot?.customer?.id;\n  const customer2 = case2.serviceCaseCustomerMachineSnapshot?.customer?.id;\n  \n  if (customer1 === customer2) return 1.0;\n  return 0;\n}\n\nfunction calculateServiceOrgSimilarity(case1, case2) {\n  const org1 = case1.serviceCaseServiceOrganisationSnapshot?.serviceOrganisationId;\n  const org2 = case2.serviceCaseServiceOrganisationSnapshot?.serviceOrganisationId;\n  \n  if (org1 === org2) return 1.0;\n  return 0;\n}\n\n// Overall similarity calculation\nfunction calculateSimilarity(targetCase, compareCase) {\n  if (targetCase.id === compareCase.id) return 0; // Same case\n  \n  const weights = {\n    machineModel: 0.35,\n    description: 0.25,\n    title: 0.15,\n    severity: 0.15,\n    customer: 0.05,\n    serviceOrg: 0.05\n  };\n  \n  const scores = {\n    machineModel: calculateMachineModelSimilarity(targetCase, compareCase),\n    description: calculateDescriptionSimilarity(targetCase.description, compareCase.description),\n    title: calculateTitleSimilarity(targetCase.title, compareCase.title),\n    severity: calculateSeveritySimilarity(targetCase.severity, compareCase.severity),\n    customer: calculateCustomerSimilarity(targetCase, compareCase),\n    serviceOrg: calculateServiceOrgSimilarity(targetCase, compareCase)\n  };\n  \n  const totalScore = Object.keys(weights).reduce((sum, key) => {\n    return sum + (scores[key] * weights[key]);\n  }, 0);\n  \n  return {\n    totalScore,\n    scores,\n    weights\n  };\n}\n\n// Find similar cases\nconst similarCases = allCases\n  .map(compareCase => {\n    const similarity = calculateSimilarity(targetCase, compareCase);\n    return {\n      case: compareCase,\n      similarity: similarity.totalScore,\n      similarityBreakdown: similarity.scores,\n      weights: similarity.weights\n    };\n  })\n  .filter(result => result.similarity >= similarityThreshold)\n  .sort((a, b) => b.similarity - a.similarity)\n  .slice(0, maxResults);\n\n// Pattern analysis\nfunction analyzePatterns(similarCases) {\n  if (similarCases.length === 0) return {};\n  \n  const patterns = {\n    machineModels: {},\n    severities: {},\n    resolutionRates: { solved: 0, unsolved: 0, pending: 0 },\n    avgResolutionTime: [],\n    commonKeywords: {},\n    serviceOrganizations: {}\n  };\n  \n  similarCases.forEach(({ case: c }) => {\n    // Machine model patterns\n    const model = c.serviceCaseMachineSnapshot?.modelName;\n    if (model) {\n      patterns.machineModels[model] = (patterns.machineModels[model] || 0) + 1;\n    }\n    \n    // Severity patterns\n    if (c.severity) {\n      patterns.severities[c.severity] = (patterns.severities[c.severity] || 0) + 1;\n    }\n    \n    // Resolution patterns\n    if (c.closingReport) {\n      if (c.closingReport.isSolved) {\n        patterns.resolutionRates.solved++;\n      } else {\n        patterns.resolutionRates.unsolved++;\n      }\n    } else if (c.state?.isClosed) {\n      patterns.resolutionRates.unsolved++;\n    } else {\n      patterns.resolutionRates.pending++;\n    }\n    \n    // Resolution time patterns\n    if (c.createdAt && c.closedAt) {\n      const resolutionTime = (new Date(c.closedAt) - new Date(c.createdAt)) / (1000 * 60 * 60);\n      patterns.avgResolutionTime.push(resolutionTime);\n    }\n    \n    // Service organization patterns\n    const org = c.serviceCaseServiceOrganisationSnapshot?.name;\n    if (org) {\n      patterns.serviceOrganizations[org] = (patterns.serviceOrganizations[org] || 0) + 1;\n    }\n    \n    // Keyword extraction from descriptions\n    if (c.description) {\n      const words = c.description.toLowerCase().split(/\\s+/).filter(w => w.length > 4);\n      words.forEach(word => {\n        patterns.commonKeywords[word] = (patterns.commonKeywords[word] || 0) + 1;\n      });\n    }\n  });\n  \n  // Calculate averages\n  if (patterns.avgResolutionTime.length > 0) {\n    const sum = patterns.avgResolutionTime.reduce((a, b) => a + b, 0);\n    patterns.avgResolutionTimeHours = Math.round(sum / patterns.avgResolutionTime.length);\n  }\n  \n  return patterns;\n}\n\n// Extract solutions from similar resolved cases\nfunction extractSolutions(similarCases) {\n  return similarCases\n    .filter(({ case: c }) => c.closingReport?.isSolved && c.closingReport?.notes)\n    .map(({ case: c, similarity }) => ({\n      caseId: c.displayId,\n      similarity: Math.round(similarity * 100),\n      solution: c.closingReport.notes,\n      resolutionTime: c.createdAt && c.closedAt ? \n        Math.round((new Date(c.closedAt) - new Date(c.createdAt)) / (1000 * 60 * 60)) : null,\n      assignee: c.scmAssignee?.name\n    }))\n    .sort((a, b) => b.similarity - a.similarity);\n}\n\n// Generate insights based on patterns\nfunction generateInsights(patterns, similarCases, targetCase) {\n  const insights = [];\n  const caseCount = similarCases.length;\n  \n  if (caseCount === 0) {\n    insights.push('No similar cases found - this appears to be a unique issue.');\n    return insights;\n  }\n  \n  insights.push(`Found ${caseCount} similar case${caseCount > 1 ? 's' : ''} for pattern analysis.`);\n  \n  // Machine model insights\n  const topModel = Object.entries(patterns.machineModels)\n    .sort(([,a], [,b]) => b - a)[0];\n  if (topModel) {\n    insights.push(`Most common machine model: ${topModel[0]} (${topModel[1]} cases)`);\n  }\n  \n  // Resolution rate insights\n  const total = patterns.resolutionRates.solved + patterns.resolutionRates.unsolved + patterns.resolutionRates.pending;\n  if (total > 0) {\n    const successRate = Math.round((patterns.resolutionRates.solved / total) * 100);\n    insights.push(`Resolution success rate: ${successRate}% (${patterns.resolutionRates.solved}/${total})`);\n  }\n  \n  // Time insights\n  if (patterns.avgResolutionTimeHours) {\n    const days = Math.floor(patterns.avgResolutionTimeHours / 24);\n    const hours = patterns.avgResolutionTimeHours % 24;\n    insights.push(`Average resolution time: ${days}d ${hours}h`);\n  }\n  \n  // Severity insights\n  const severityCount = Object.keys(patterns.severities).length;\n  if (severityCount > 1) {\n    insights.push('Similar cases span multiple severity levels - consider escalation patterns.');\n  }\n  \n  // Critical threshold analysis\n  if (caseCount >= 3) {\n    insights.push('ðŸš¨ CRITICAL: 3+ similar cases detected - consider systemic issue investigation.');\n    insights.push('Recommend: Root cause analysis and preventive measures.');\n  }\n  \n  return insights;\n}\n\n// Compile final result\nconst patterns = analyzePatterns(similarCases);\nconst solutions = extractSolutions(similarCases);\nconst insights = generateInsights(patterns, similarCases, targetCase);\n\nconst result = {\n  targetCase: {\n    id: targetCase.id,\n    displayId: targetCase.displayId,\n    title: targetCase.title\n  },\n  \n  similarCases: similarCases.map(({ case: c, similarity, similarityBreakdown }) => ({\n    id: c.id,\n    displayId: c.displayId,\n    title: c.title,\n    similarity: Math.round(similarity * 100),\n    similarityBreakdown: Object.entries(similarityBreakdown).map(([key, value]) => ({\n      factor: key,\n      score: Math.round(value * 100)\n    })),\n    status: c.state?.name,\n    isClosed: c.state?.isClosed,\n    isResolved: c.closingReport?.isSolved,\n    machine: `${c.serviceCaseMachineSnapshot?.brand || ''} ${c.serviceCaseMachineSnapshot?.modelName || ''}`.trim(),\n    customer: c.serviceCaseCustomerMachineSnapshot?.customer?.name\n  })),\n  \n  patterns,\n  solutions,\n  insights,\n  \n  analysis: {\n    totalSimilarCases: similarCases.length,\n    highSimilarity: similarCases.filter(s => s.similarity >= 0.8).length,\n    mediumSimilarity: similarCases.filter(s => s.similarity >= 0.6 && s.similarity < 0.8).length,\n    criticalThresholdReached: similarCases.length >= 3,\n    patternStrength: similarCases.length > 0 ? \n      Math.round((similarCases.reduce((sum, s) => sum + s.similarity, 0) / similarCases.length) * 100) : 0\n  },\n  \n  recommendations: [\n    similarCases.length >= 3 ? 'Conduct systematic root cause analysis' : 'Monitor for additional similar cases',\n    solutions.length > 0 ? 'Review documented solutions from similar cases' : 'Document resolution for future reference',\n    'Consider preventive measures based on identified patterns',\n    patterns.machineModels ? 'Analyze machine model reliability patterns' : 'Track machine model performance'\n  ],\n  \n  metadata: {\n    analyzedAt: new Date().toISOString(),\n    threshold: similarityThreshold,\n    algorithmsUsed: ['machine_model_matching', 'text_similarity', 'severity_correlation'],\n    totalCasesAnalyzed: allCases.length\n  }\n};\n\nreturn result;"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.3,
      "position": [
        -1136,
        128
      ],
      "id": "findSimilarCases-tool-id",
      "name": "findSimilarCases",
      "alwaysOutputData": true,
      "onError": "continueErrorOutput"
    }
  ],
  "connections": {
    "findSimilarCases": {
      "ai_tool": [
        []
      ]
    }
  },
  "pinData": {},
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "90f7e16e88b8af51a9fefb468989df8864c6fa45b8b0deeeccb82ce7f608fa65"
  }
}