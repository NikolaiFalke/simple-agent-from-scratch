{
  "nodes": [
    {
      "parameters": {
        "description": "Generates comprehensive service case analysis reports with timeline, performance metrics, and actionable insights. Analyzes case lifecycle, assignment efficiency, resolution patterns, and provides role-appropriate recommendations for service optimization.",
        "jsCode": "// Service Case Analysis Engine\n// Generates comprehensive reports with timeline analysis and insights\n\nconst caseData = $input.first().json.caseData;\nconst userRole = $input.first().json.userRole || 'SERVICE_PROVIDER';\nconst analysisType = $input.first().json.analysisType || 'comprehensive';\n\nif (!caseData) {\n  return { error: 'Case data is required for analysis' };\n}\n\n// Helper functions for analysis\nfunction calculateDuration(start, end) {\n  if (!start || !end) return null;\n  const startDate = new Date(start);\n  const endDate = new Date(end);\n  const diffMs = endDate - startDate;\n  const diffHours = Math.round(diffMs / (1000 * 60 * 60));\n  const diffDays = Math.round(diffHours / 24);\n  \n  if (diffDays > 0) {\n    return `${diffDays} days, ${diffHours % 24} hours`;\n  }\n  return `${diffHours} hours`;\n}\n\nfunction analyzePriority(priority) {\n  const levels = {\n    1: 'Critical - Immediate attention required',\n    2: 'High - Urgent resolution needed',\n    3: 'Medium - Standard priority',\n    4: 'Low - Can be scheduled',\n    5: 'Planning - Long-term consideration'\n  };\n  return levels[priority] || 'Unknown priority level';\n}\n\nfunction analyzeSeverity(severity) {\n  const impacts = {\n    'MACHINE_BREAKDOWN': 'Critical - Machine completely non-functional',\n    'PRODUCTION_IMPAIRED': 'High - Production efficiency reduced',\n    'NO_IMPAIRMENT': 'Low - No immediate production impact'\n  };\n  return impacts[severity] || 'Unknown severity level';\n}\n\nfunction analyzeTimeline(caseData) {\n  const timeline = [];\n  \n  if (caseData.createdAt) {\n    timeline.push({\n      event: 'Case Created',\n      timestamp: caseData.createdAt,\n      details: `Created by ${caseData.scmCreator?.name || 'Unknown'}`\n    });\n  }\n  \n  if (caseData.firstTimeAssignedAt) {\n    timeline.push({\n      event: 'First Assignment',\n      timestamp: caseData.firstTimeAssignedAt,\n      details: `Assigned to ${caseData.scmAssignee?.name || 'Unknown'}`\n    });\n  }\n  \n  if (caseData.firstTimeInProgressAt) {\n    timeline.push({\n      event: 'Work Started',\n      timestamp: caseData.firstTimeInProgressAt,\n      details: 'Case moved to in-progress status'\n    });\n  }\n  \n  if (caseData.closedAt) {\n    timeline.push({\n      event: 'Case Closed',\n      timestamp: caseData.closedAt,\n      details: `Resolved: ${caseData.closingReport?.isSolved ? 'Successfully' : 'Unresolved'}`\n    });\n  }\n  \n  return timeline.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));\n}\n\nfunction generateExecutiveSummary(caseData) {\n  const isResolved = caseData.closingReport?.isSolved;\n  const totalDuration = calculateDuration(caseData.createdAt, caseData.closedAt || new Date());\n  const assignmentDelay = calculateDuration(caseData.createdAt, caseData.firstTimeAssignedAt);\n  \n  return {\n    caseId: caseData.displayId,\n    status: caseData.state?.name || 'Unknown',\n    resolution: isResolved ? 'Resolved Successfully' : (caseData.state?.isClosed ? 'Closed Unresolved' : 'In Progress'),\n    totalDuration: totalDuration,\n    assignmentDelay: assignmentDelay,\n    priority: analyzePriority(caseData.priority),\n    severity: analyzeSeverity(caseData.severity),\n    customer: caseData.serviceCaseCustomerMachineSnapshot?.customer?.name,\n    machine: `${caseData.serviceCaseMachineSnapshot?.brand || ''} ${caseData.serviceCaseMachineSnapshot?.modelName || 'Unknown Model'}`.trim(),\n    serviceOrg: caseData.serviceCaseServiceOrganisationSnapshot?.name\n  };\n}\n\nfunction generateTechnicalAnalysis(caseData) {\n  const machine = caseData.serviceCaseMachineSnapshot;\n  const customerMachine = caseData.serviceCaseCustomerMachineSnapshot;\n  \n  return {\n    machineDetails: {\n      model: machine?.modelName,\n      brand: machine?.brand,\n      technology: machine?.technology,\n      serialNumber: machine?.serialNumber,\n      hasIoTDevice: !!machine?.edgeDevice?.iotDeviceId,\n      iotDeviceId: machine?.edgeDevice?.iotDeviceId\n    },\n    customerContext: {\n      customer: customerMachine?.customer?.name,\n      machineModelId: customerMachine?.machineModelId\n    },\n    issueAnalysis: {\n      title: caseData.title,\n      description: caseData.description,\n      severity: caseData.severity,\n      customFields: caseData.customFields?.map(cf => ({\n        field: cf.definition.displayName,\n        value: cf.value\n      })) || []\n    }\n  };\n}\n\nfunction generatePerformanceMetrics(caseData) {\n  const created = new Date(caseData.createdAt);\n  const assigned = caseData.firstTimeAssignedAt ? new Date(caseData.firstTimeAssignedAt) : null;\n  const started = caseData.firstTimeInProgressAt ? new Date(caseData.firstTimeInProgressAt) : null;\n  const closed = caseData.closedAt ? new Date(caseData.closedAt) : null;\n  const now = new Date();\n  \n  const metrics = {\n    timeToAssignment: assigned ? Math.round((assigned - created) / (1000 * 60 * 60)) : null,\n    timeToStart: started ? Math.round((started - created) / (1000 * 60 * 60)) : null,\n    timeToResolution: closed ? Math.round((closed - created) / (1000 * 60 * 60)) : null,\n    currentAge: Math.round((now - created) / (1000 * 60 * 60)),\n    isOverdue: false // This would require SLA data\n  };\n  \n  // Performance indicators\n  const indicators = [];\n  if (metrics.timeToAssignment && metrics.timeToAssignment > 24) {\n    indicators.push('âš ï¸ Slow assignment (>24h)');\n  }\n  if (metrics.timeToStart && metrics.timeToStart > 48) {\n    indicators.push('âš ï¸ Delayed start (>48h)');\n  }\n  if (!closed && metrics.currentAge > 168) {\n    indicators.push('ðŸš¨ Long-running case (>1 week)');\n  }\n  if (closed && caseData.closingReport?.isSolved) {\n    indicators.push('âœ… Successfully resolved');\n  }\n  \n  return { ...metrics, indicators };\n}\n\nfunction generateRoleSpecificInsights(caseData, role) {\n  const insights = [];\n  \n  switch (role) {\n    case 'SERVICE_PROVIDER':\n      insights.push('**Strategic Insights:**');\n      if (caseData.closingReport?.isSolved) {\n        insights.push('â€¢ Case successfully resolved - good customer experience');\n      }\n      if (caseData.priority >= 3) {\n        insights.push('â€¢ Lower priority case - consider resource allocation efficiency');\n      }\n      insights.push('â€¢ Customer: ' + (caseData.serviceCaseCustomerMachineSnapshot?.customer?.name || 'Unknown'));\n      break;\n      \n    case 'OPERATOR':\n      insights.push('**Operational Insights:**');\n      if (caseData.firstTimeAssignedAt) {\n        insights.push('â€¢ Case properly assigned - good workflow execution');\n      }\n      if (caseData.serviceCaseMachineSnapshot?.technology) {\n        insights.push('â€¢ Technology focus: ' + caseData.serviceCaseMachineSnapshot.technology);\n      }\n      break;\n      \n    case 'DEVICE_PROVISIONER':\n      insights.push('**Technical Insights:**');\n      if (caseData.serviceCaseMachineSnapshot?.edgeDevice) {\n        insights.push('â€¢ IoT device involved - connectivity may be factor');\n      }\n      if (caseData.serviceCaseMachineSnapshot?.serialNumber) {\n        insights.push('â€¢ Serial tracked: ' + caseData.serviceCaseMachineSnapshot.serialNumber);\n      }\n      break;\n  }\n  \n  return insights;\n}\n\n// Generate comprehensive analysis\nconst analysis = {\n  summary: generateExecutiveSummary(caseData),\n  timeline: analyzeTimeline(caseData),\n  technical: generateTechnicalAnalysis(caseData),\n  performance: generatePerformanceMetrics(caseData),\n  insights: generateRoleSpecificInsights(caseData, userRole),\n  \n  // Solution information\n  solution: caseData.closingReport ? {\n    solved: caseData.closingReport.isSolved,\n    notes: caseData.closingReport.notes,\n    hasDocumentation: !!caseData.closingReport.notes\n  } : null,\n  \n  // Recommendations\n  recommendations: [\n    'Use findSimilarCases tool to identify patterns',\n    'Review machine documentation for technical context',\n    'Consider preventive measures based on failure analysis'\n  ],\n  \n  // Analysis metadata\n  metadata: {\n    analyzedAt: new Date().toISOString(),\n    analysisType: analysisType,\n    userRole: userRole,\n    caseDisplayId: caseData.displayId\n  }\n};\n\nreturn analysis;"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.3,
      "position": [
        -1136,
        128
      ],
      "id": "analyzeServiceCase-tool-id",
      "name": "analyzeServiceCase",
      "alwaysOutputData": true,
      "onError": "continueErrorOutput"
    }
  ],
  "connections": {
    "analyzeServiceCase": {
      "ai_tool": [
        []
      ]
    }
  },
  "pinData": {},
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "90f7e16e88b8af51a9fefb468989df8864c6fa45b8b0deeeccb82ce7f608fa65"
  }
}